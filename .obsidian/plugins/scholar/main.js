/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/exponential-backoff/dist/options.js
var require_options = __commonJS({
  "node_modules/exponential-backoff/dist/options.js"(exports) {
    "use strict";
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var defaultOptions = {
      delayFirstAttempt: false,
      jitter: "none",
      maxDelay: Infinity,
      numOfAttempts: 10,
      retry: function() {
        return true;
      },
      startingDelay: 100,
      timeMultiple: 2
    };
    function getSanitizedOptions(options) {
      var sanitized = __assign(__assign({}, defaultOptions), options);
      if (sanitized.numOfAttempts < 1) {
        sanitized.numOfAttempts = 1;
      }
      return sanitized;
    }
    exports.getSanitizedOptions = getSanitizedOptions;
  }
});

// node_modules/exponential-backoff/dist/jitter/full/full.jitter.js
var require_full_jitter = __commonJS({
  "node_modules/exponential-backoff/dist/jitter/full/full.jitter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function fullJitter(delay) {
      var jitteredDelay = Math.random() * delay;
      return Math.round(jitteredDelay);
    }
    exports.fullJitter = fullJitter;
  }
});

// node_modules/exponential-backoff/dist/jitter/no/no.jitter.js
var require_no_jitter = __commonJS({
  "node_modules/exponential-backoff/dist/jitter/no/no.jitter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function noJitter(delay) {
      return delay;
    }
    exports.noJitter = noJitter;
  }
});

// node_modules/exponential-backoff/dist/jitter/jitter.factory.js
var require_jitter_factory = __commonJS({
  "node_modules/exponential-backoff/dist/jitter/jitter.factory.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var full_jitter_1 = require_full_jitter();
    var no_jitter_1 = require_no_jitter();
    function JitterFactory(options) {
      switch (options.jitter) {
        case "full":
          return full_jitter_1.fullJitter;
        case "none":
        default:
          return no_jitter_1.noJitter;
      }
    }
    exports.JitterFactory = JitterFactory;
  }
});

// node_modules/exponential-backoff/dist/delay/delay.base.js
var require_delay_base = __commonJS({
  "node_modules/exponential-backoff/dist/delay/delay.base.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var jitter_factory_1 = require_jitter_factory();
    var Delay = (
      /** @class */
      function() {
        function Delay2(options) {
          this.options = options;
          this.attempt = 0;
        }
        Delay2.prototype.apply = function() {
          var _this = this;
          return new Promise(function(resolve) {
            return setTimeout(resolve, _this.jitteredDelay);
          });
        };
        Delay2.prototype.setAttemptNumber = function(attempt) {
          this.attempt = attempt;
        };
        Object.defineProperty(Delay2.prototype, "jitteredDelay", {
          get: function() {
            var jitter = jitter_factory_1.JitterFactory(this.options);
            return jitter(this.delay);
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(Delay2.prototype, "delay", {
          get: function() {
            var constant = this.options.startingDelay;
            var base = this.options.timeMultiple;
            var power = this.numOfDelayedAttempts;
            var delay = constant * Math.pow(base, power);
            return Math.min(delay, this.options.maxDelay);
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(Delay2.prototype, "numOfDelayedAttempts", {
          get: function() {
            return this.attempt;
          },
          enumerable: true,
          configurable: true
        });
        return Delay2;
      }()
    );
    exports.Delay = Delay;
  }
});

// node_modules/exponential-backoff/dist/delay/skip-first/skip-first.delay.js
var require_skip_first_delay = __commonJS({
  "node_modules/exponential-backoff/dist/delay/skip-first/skip-first.delay.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var delay_base_1 = require_delay_base();
    var SkipFirstDelay = (
      /** @class */
      function(_super) {
        __extends(SkipFirstDelay2, _super);
        function SkipFirstDelay2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        SkipFirstDelay2.prototype.apply = function() {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              return [2, this.isFirstAttempt ? true : _super.prototype.apply.call(this)];
            });
          });
        };
        Object.defineProperty(SkipFirstDelay2.prototype, "isFirstAttempt", {
          get: function() {
            return this.attempt === 0;
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(SkipFirstDelay2.prototype, "numOfDelayedAttempts", {
          get: function() {
            return this.attempt - 1;
          },
          enumerable: true,
          configurable: true
        });
        return SkipFirstDelay2;
      }(delay_base_1.Delay)
    );
    exports.SkipFirstDelay = SkipFirstDelay;
  }
});

// node_modules/exponential-backoff/dist/delay/always/always.delay.js
var require_always_delay = __commonJS({
  "node_modules/exponential-backoff/dist/delay/always/always.delay.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    var delay_base_1 = require_delay_base();
    var AlwaysDelay = (
      /** @class */
      function(_super) {
        __extends(AlwaysDelay2, _super);
        function AlwaysDelay2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        return AlwaysDelay2;
      }(delay_base_1.Delay)
    );
    exports.AlwaysDelay = AlwaysDelay;
  }
});

// node_modules/exponential-backoff/dist/delay/delay.factory.js
var require_delay_factory = __commonJS({
  "node_modules/exponential-backoff/dist/delay/delay.factory.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var skip_first_delay_1 = require_skip_first_delay();
    var always_delay_1 = require_always_delay();
    function DelayFactory(options, attempt) {
      var delay = initDelayClass(options);
      delay.setAttemptNumber(attempt);
      return delay;
    }
    exports.DelayFactory = DelayFactory;
    function initDelayClass(options) {
      if (!options.delayFirstAttempt) {
        return new skip_first_delay_1.SkipFirstDelay(options);
      }
      return new always_delay_1.AlwaysDelay(options);
    }
  }
});

// node_modules/exponential-backoff/dist/backoff.js
var require_backoff = __commonJS({
  "node_modules/exponential-backoff/dist/backoff.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var options_1 = require_options();
    var delay_factory_1 = require_delay_factory();
    function backOff2(request2, options) {
      if (options === void 0) {
        options = {};
      }
      return __awaiter(this, void 0, void 0, function() {
        var sanitizedOptions, backOff3;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              sanitizedOptions = options_1.getSanitizedOptions(options);
              backOff3 = new BackOff(request2, sanitizedOptions);
              return [4, backOff3.execute()];
            case 1:
              return [2, _a.sent()];
          }
        });
      });
    }
    exports.backOff = backOff2;
    var BackOff = (
      /** @class */
      function() {
        function BackOff2(request2, options) {
          this.request = request2;
          this.options = options;
          this.attemptNumber = 0;
        }
        BackOff2.prototype.execute = function() {
          return __awaiter(this, void 0, void 0, function() {
            var e_1, shouldRetry;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  if (!!this.attemptLimitReached)
                    return [3, 7];
                  _a.label = 1;
                case 1:
                  _a.trys.push([1, 4, , 6]);
                  return [4, this.applyDelay()];
                case 2:
                  _a.sent();
                  return [4, this.request()];
                case 3:
                  return [2, _a.sent()];
                case 4:
                  e_1 = _a.sent();
                  this.attemptNumber++;
                  return [4, this.options.retry(e_1, this.attemptNumber)];
                case 5:
                  shouldRetry = _a.sent();
                  if (!shouldRetry || this.attemptLimitReached) {
                    throw e_1;
                  }
                  return [3, 6];
                case 6:
                  return [3, 0];
                case 7:
                  throw new Error("Something went wrong.");
              }
            });
          });
        };
        Object.defineProperty(BackOff2.prototype, "attemptLimitReached", {
          get: function() {
            return this.attemptNumber >= this.options.numOfAttempts;
          },
          enumerable: true,
          configurable: true
        });
        BackOff2.prototype.applyDelay = function() {
          return __awaiter(this, void 0, void 0, function() {
            var delay;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  delay = delay_factory_1.DelayFactory(this.options, this.attemptNumber);
                  return [4, delay.apply()];
                case 1:
                  _a.sent();
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
        return BackOff2;
      }()
    );
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => ObsidianScholarPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian6 = require("obsidian");

// src/constants.ts
var ARXIV_BIBTEX_API = "https://arxiv.org/bibtex/";
var ARXIV_REST_API = "https://export.arxiv.org/api/query?id_list=";
var ARXIV_URL_SUFFIX_ON_S2 = "arXiv:";
var ACL_ANTHOLOGY_URL_SUFFIX_ON_S2 = "ACL:";
var SEMANTIC_SCHOLAR_FIELDS = "fields=authors,title,abstract,url,venue,year,publicationDate,externalIds,isOpenAccess,openAccessPdf,citationStyles&limit=5";
var SEMANTIC_SCHOLAR_API = "https://api.semanticscholar.org/graph/v1/paper/";
var SEMANTIC_SCHOLAR_SEARCH_API = "https://api.semanticscholar.org/graph/v1/paper/search/?query=";
var SEMANTIC_SCHOLAR_REFERENCE_SEARCH_FIELDS = "/references?fields=authors,title,abstract,url,venue,year,publicationDate,externalIds,isOpenAccess,openAccessPdf,citationStyles&limit=50";
var COMMAND_PAPER_NOTE_ID = "create-paper-note-from-url";
var COMMAND_PAPER_NOTE_NAME = "Add paper to Library";
var COMMAND_PAPER_MODAL_TITLE = "Enter a Paper URL";
var COMMAND_PAPER_MODAL_PLACEHOLDERS = [
  "https://arxiv.org/abs/xxxx.xxxx",
  "https://aclanthology.org/2022.acl-long.1/",
  "https://www.semanticscholar.org/paper/some-text/xxxx"
];
var COMMAND_PAPER_MODAL_DESC = "Right now we support paper URLs from arXiv, Semantic Scholar, and ACL Anthology.";
var COMMAND_SEARCH_PAPER = "search-paper";
var COMMAND_SEARCH_PAPER_NAME = "Search Paper";
var COMMAND_COPY_PAPER_BIBTEX = "copy-paper-bibtex";
var COMMAND_COPY_PAPER_BIBTEX_NAME = "Copy Paper BibTeX";
var COMMAND_SEARCH_PAPER_REFERENCES = "search-paper-references";
var COMMAND_SEARCH_PAPER_REFERENCES_NAME = "Search Paper References";
var COMMAND_REMOVE_PAPER = "remove-paper";
var COMMAND_REMOVE_PAPER_NAME = "Remove Paper from Library";
var COMMAND_OPEN_PDF_IN_SYSTEM_APP = "open-pdf-in-system-app";
var COMMAND_OPEN_PDF_IN_SYSTEM_APP_NAME = "Open PDF in System App";
var COMMAND_ADD_PAPER_PDF = "add-paper-pdf";
var COMMAND_ADD_PAPER_PDF_NAME = "Add Paper PDF";
var SETTING_GENERAL_HEADER = "Library Settings";
var SETTING_NOTE_FOLDER_NAME = "Note folder";
var SETTING_NOTE_FOLDER_DESC = "Folder to create paper notes in.";
var SETTING_NOTE_FOLDER_DEFAULT = "(root of the vault)";
var SETTING_PDF_DOWNLOAD_NAME = "PDF folder";
var SETTING_PDF_DOWNLOAD_DESC = "Choose the path to download the PDF to.";
var SETTING_PDF_DOWNLOAD_FOLDER_DEFAULT = "(root of the vault)";
var SETTING_IS_OPEN_PDF_WITH_NOTE_NAME = "Open PDF with note?";
var SETTING_IS_OPEN_PDF_WITH_NOTE_DESC = "Whether to open the PDF alongside the note.";
var SETTING_IS_ADD_TO_BIB_FILE_NAME = "Save paper BibTeX to a .bib file?";
var SETTING_IS_ADD_TO_BIB_FILE_DESC = 'If disabled, you cannot execute the "Copy Paper BibTeX" command.';
var SETTING_ADD_TO_BIB_FILE_NAME = "Save the BibTeX to";
var SETTING_ADD_TO_BIB_FILE_DESC = "Choose the .bib file to save the BibTeX to.";
var SETTING_SYS_SEP = "System path separator";
var SETTING_SYS_SEP_DESC = "Used in the paper pdf path. Default is /; For Windows, use \\\\. Restart Obsidian after changing.";
var SETTING_NOTE_HEADER = "Note Settings";
var SETTING_FRONTMATTER_ADD_ALIASES_NAME = "Add aliases key in the note frontmatter?";
var SETTING_FRONTMATTER_ADD_ALIASES_DESC = "If enabled, it will add the @{{citeky}} as an alias to the note.";
var SETTING_FRONTMATTER_ADD_ANNOTATION_NAME = "Add annotation key in the note frontmatter?";
var SETTING_FRONTMATTER_ADD_ANNOTATION_DESC = "If enabled, it will add the annotation-target key; use with the Annotator plugin.";
var SETTING_TEMPLATE_NAME = "Note Template";
var SETTING_TEMPLATE_DESC = "If set, we will use you own template for the paper note.";
var SETTING_S2API_NAME = "Semantic Scholar API Key";
var SETTING_S2API_DESC = "Provide an Semantic Scholar API key can help you avoid rate limits when calling the API. You can obtain an API key from https://api.semanticscholar.org/.";
var SETTING_PDF_OVERRIDE_NAME = "Override existing PDFs";
var SETTING_PDF_OVERRIDE_DESC = "If enabled, adding a new PDF will replace the existing one. If disabled, the existing PDF will be renamed as a backup with timestamp.";
var SETTING_OPEN_PDF_AFTER_UPDATE_NAME = "Open PDF after update";
var SETTING_OPEN_PDF_AFTER_UPDATE_DESC = "If enabled, the PDF will be opened automatically after adding it to a paper.";
var NOTICE_RETRIEVING_ARXIV = "Retrieving paper information from arXiv API.";
var NOTICE_RETRIEVING_S2 = "Retrieving paper information from Semantic Scholar API.";
var NOTICE_DOWNLOADING_S2 = "Downloading Paper From S2";
var NOTICE_NOT_BIB_FILE = "The file you selected is not a .bib file.";
var NOTICE_NO_BIB_FILE_SELECTED = "No .bib file is selected. Please create one first.";
var NOTICE_PAPER_NOTE_DOWNLOAD_ERROR = "Something went wrong. Check the Obsidian console if the error persists.";
var FILE_ALREADY_EXISTS = "Unable to create note. File already exists. Opening existing file.";
var NOTICE_SEARCH_BIBTEX_NOT_FOUND = "The BibTeX for this paper is not found. You might search the bibtext file manually.";
var NOTICE_SEARCH_BIBTEX_ERROR = "The BibTeX for this paper is not found. You might search the bibtext file manually.";
var NOTICE_SEARCH_BIBTEX_COPIED = "The BibTeX of this paper is copied to the clipboard.";
var NOTE_FRONTMATTER_DEFAULT = `title: "{{title}}"
added: "{{date}}"
authors: "{{authors}}"
tags: 
url: "{{url}}"
pdf: "{{pdf}}"
citekey: "{{citekey}}"
year: "{{publicationDate:YYYY}}"
abstract: "{{abstract}}"`;
var NOTE_FRONTMATTER_ALIASES = `aliases: "@{{citekey}}"`;
var NOTE_FRONTMATTER_ANNOTATION = `annotation-target: "{{pdf}}"`;

// src/paperData.ts
var import_obsidian2 = require("obsidian");

// src/utility.ts
var import_obsidian = require("obsidian");
function getDate(input) {
  let duration;
  if ((input == null ? void 0 : input.offset) !== null && (input == null ? void 0 : input.offset) !== void 0 && typeof input.offset === "number") {
    duration = window.moment.duration(input.offset, "days");
  }
  return (input == null ? void 0 : input.format) ? window.moment().add(duration).format(input.format) : window.moment().add(duration).format("YYYY-MM-DD");
}
function formatTimeString(input, format) {
  return format ? window.moment(input).format(format) : window.moment(input).format("YYYY-MM-DD");
}
function trimString(str) {
  if (str == null)
    return "";
  return str.replace(/\s+/g, " ").trim();
}
function isValidUrl(s) {
  var regex = /^(https?:\/\/)?((([a-z\d]([a-z\d-]*[a-z\d])*)\.)+[a-z]{2,}|((\d{1,3}\.){3}\d{1,3}))(\:\d+)?(\/[-a-z\d%_.~+]*)*(\?[;&a-z\d%_.~+=-]*)?(\#[-a-z\d_]*)?$/i;
  return !!regex.test(s);
}
function splitBibtex(bibtex) {
  let regex = /(@.*?{[^@]*})/gs;
  return bibtex.match(regex);
}
function getSystemPathSeparator() {
  return import_obsidian.Platform.isWin ? "\\" : "/";
}
function parseBibString(bibString) {
  const result = {};
  const arxivPatterns = [
    /arxiv[:\s]+(\d{4}\.\d{4,5})/i,
    /arxiv[:\s]+([a-z\-]+\/\d{7})/i,
    // older format like cond-mat/9901001
    /(?:^|\s)(\d{4}\.\d{4,5})(?:\s|$)/
    // just the number pattern with word boundaries
  ];
  for (const pattern of arxivPatterns) {
    const match = bibString.match(pattern);
    if (match) {
      result.arxivId = match[1];
      result.arxivUrl = `https://arxiv.org/abs/${match[1]}`;
      break;
    }
  }
  if (!result.arxivUrl) {
    const urlPattern = /https?:\/\/[^\s\)]+/gi;
    const urlMatches = bibString.match(urlPattern);
    if (urlMatches && urlMatches.length > 0) {
      result.url = urlMatches[0].replace(/[.,;:]+$/, "");
    }
  }
  const quotedPattern = /["']([^"']+)["']/;
  const quotedMatch = bibString.match(quotedPattern);
  if (quotedMatch) {
    result.title = quotedMatch[1].trim();
  } else {
    const afterYearPattern = /\b(19|20)\d{2}[a-z]?\.\s+([^.]+?)(?:\.|$)/i;
    const yearMatch = bibString.match(afterYearPattern);
    if (yearMatch) {
      let title = yearMatch[2].trim();
      title = title.replace(/^(In |in |In:|in:)\s*/i, "");
      title = title.replace(/\s*(arxiv|arXiv|preprint|journal|conference|proceedings).*/i, "");
      title = title.replace(/,?\s*(pages?|pp?\.?)\s*\d+[-–]\d+\.?$/i, "");
      result.title = title.trim();
    } else {
      const sentences = bibString.split(/[.!?]+/);
      for (const sentence of sentences) {
        if (sentence.match(/\b(pages?|pp|arxiv|proceedings|conference|journal)\b/i)) {
          continue;
        }
        const words = sentence.trim().split(/\s+/);
        const capitalizedWords = words.filter((w) => /^[A-Z]/.test(w));
        if (capitalizedWords.length >= 3 && words.length >= 5) {
          result.title = sentence.trim().replace(/^.*?\d{4}[a-z]?\.\s*/i, "").replace(/\s*(in|In)\s+.*/i, "");
          break;
        }
      }
    }
  }
  if (result.title) {
    result.title = result.title.replace(/^["']|["']$/g, "");
    result.title = result.title.replace(/\s+/g, " ").trim();
  }
  return result;
}

// src/paperData.ts
var import_exponential_backoff = __toESM(require_backoff());
var import_obsidian3 = require("obsidian");
function getIdentifierFromUrl(url) {
  if (url.endsWith("/"))
    url = url.slice(0, -1);
  return url.split("/").slice(-1)[0];
}
async function makeRequestWithRetry(url, apiKey) {
  const makeRequest = async () => {
    const requestOptions = {
      url,
      headers: apiKey && apiKey !== "" ? { "x-api-key": apiKey } : {}
    };
    const response = await (0, import_obsidian2.request)(requestOptions);
    return response;
  };
  return (0, import_exponential_backoff.backOff)(makeRequest, {
    startingDelay: 1e3,
    // b/c the default is 1000ms according to the semanticscholar API
    numOfAttempts: 5,
    retry: (e) => {
      console.log(e);
      if (e.message.includes("429")) {
        new import_obsidian3.Notice("Rate limit exceeded. Trying again.");
        return true;
      } else if (e.message.includes("404")) {
        new import_obsidian3.Notice("The paper cannot be found on SemanticScholar. Stop trying.");
        return false;
      } else {
        return true;
      }
    }
  });
}
function getCiteKeyFromBibtex(bibtex) {
  const match = bibtex.match(/@.*\{([^,]+)/);
  return match ? match[1] : null;
}
async function fetchArxivBibtex(arxivId) {
  const bibtex = await makeRequestWithRetry(ARXIV_BIBTEX_API + arxivId);
  return bibtex;
}
async function fetchArxivPaperDataFromUrl(url) {
  var _a;
  const arxivId = getIdentifierFromUrl(url);
  const arxivData = await makeRequestWithRetry(ARXIV_REST_API + arxivId);
  const parser = new DOMParser();
  const xmlDoc = parser.parseFromString(arxivData, "text/xml");
  let title = xmlDoc.getElementsByTagName("title")[1].textContent;
  let abstract = xmlDoc.getElementsByTagName("summary")[0].textContent;
  let authorsSource = xmlDoc.getElementsByTagName("author");
  let authors = [];
  for (let i = 0; i < authorsSource.length; i++) {
    authors.push(
      authorsSource[i].getElementsByTagName("name")[0].textContent
    );
  }
  let date = xmlDoc.getElementsByTagName("published")[0].textContent;
  if (date)
    date = date.split("T")[0];
  if (title == null)
    title = "undefined";
  let pdfUrl = (_a = xmlDoc.querySelector('link[title="pdf"]')) == null ? void 0 : _a.getAttribute("href");
  let bibtex = await fetchArxivBibtex(arxivId);
  return {
    title: trimString(title),
    authors,
    url: trimString(url),
    publicationDate: trimString(date),
    abstract: trimString(abstract),
    pdfUrl,
    bibtex,
    citekey: getCiteKeyFromBibtex(bibtex)
  };
}
function parseS2paperData(json) {
  var _a, _b;
  let title = json.title;
  let abstract = json.abstract;
  let authors = json.authors ? json.authors.map((author) => author.name) : [];
  let venue = "";
  if (json.venue != null && json.venue != "")
    venue = json.venue + " " + json.year;
  let publicationDate = json.publicationDate;
  if (title == null)
    title = "undefined";
  let paperUrl = json.url;
  let pdfUrl = "";
  if (json["isOpenAccess"] && json["isOpenAccess"] === true && json["openAccessPdf"]) {
    pdfUrl = (_a = json["openAccessPdf"]) == null ? void 0 : _a.url;
  }
  if (json["externalIds"] && json["externalIds"]["ArXiv"]) {
    paperUrl = "https://arxiv.org/abs/" + json.externalIds["ArXiv"];
    pdfUrl = "https://arxiv.org/pdf/" + json.externalIds["ArXiv"];
  }
  if (json["externalIds"] && json["externalIds"]["ACL]"]) {
    paperUrl = "https://aclanthology.org/" + json.externalIds["ACL"];
    let pdfUrl2 = paperUrl;
    if (pdfUrl2.endsWith("/")) {
      pdfUrl2 = paperUrl.slice(0, -1);
    }
    pdfUrl2 = pdfUrl2 + ".pdf";
  }
  let bibtex = ((_b = json["citationStyles"]) == null ? void 0 : _b.bibtex) ? json["citationStyles"]["bibtex"] : "";
  return {
    title: trimString(title),
    authors,
    venue: trimString(venue),
    url: paperUrl,
    publicationDate: trimString(publicationDate),
    abstract: trimString(abstract),
    pdfUrl,
    bibtex,
    citekey: getCiteKeyFromBibtex(bibtex)
  };
}
async function fetchSemanticScholarPaperDataFromUrl(url, apiKey, maxRetryCount = 3, retryDelay = 2e3) {
  let s2Id = getIdentifierFromUrl(url);
  if (url.toLowerCase().includes("arxiv")) {
    s2Id = ARXIV_URL_SUFFIX_ON_S2 + s2Id.split("v")[0];
  } else if (url.toLowerCase().includes("aclanthology")) {
    s2Id = ACL_ANTHOLOGY_URL_SUFFIX_ON_S2 + s2Id;
  } else if (url.toLowerCase().includes("semanticscholar")) {
  } else {
    console.log("Invalid url: " + url);
    throw new Error("Invalid url: " + url);
  }
  let s2Data = await makeRequestWithRetry(SEMANTIC_SCHOLAR_API + s2Id + "?" + SEMANTIC_SCHOLAR_FIELDS, apiKey);
  let json = JSON.parse(s2Data);
  if (json.error != null) {
    throw new Error(json.error);
  }
  return parseS2paperData(json);
}
async function searchSemanticScholar(query, apiKey) {
  let requestUrl2 = SEMANTIC_SCHOLAR_SEARCH_API + encodeURIComponent(query) + "&" + SEMANTIC_SCHOLAR_FIELDS;
  let s2Data = await makeRequestWithRetry(requestUrl2, apiKey);
  let json = JSON.parse(s2Data);
  if (json.error != null) {
    throw new Error(json.error);
  }
  if (json.data == null || json.data.length == 0 || (json == null ? void 0 : json.total) == 0) {
    throw new Error("No data returned");
  }
  return json.data.map((paper) => parseS2paperData(paper));
}
async function fetchSemanticScholarPaperReferences(url) {
  let s2Id = getIdentifierFromUrl(url);
  if (url.toLowerCase().includes("arxiv")) {
    s2Id = ARXIV_URL_SUFFIX_ON_S2 + s2Id.split("v")[0];
  } else if (url.toLowerCase().includes("aclanthology")) {
    s2Id = ACL_ANTHOLOGY_URL_SUFFIX_ON_S2 + s2Id;
  } else if (url.toLowerCase().includes("semanticscholar")) {
  } else {
    console.log("Invalid url: " + url);
    throw new Error("Invalid url: " + url);
  }
  let s2Data = await makeRequestWithRetry(
    SEMANTIC_SCHOLAR_API + s2Id + SEMANTIC_SCHOLAR_REFERENCE_SEARCH_FIELDS
  );
  let json = JSON.parse(s2Data);
  if (json.error != null) {
    throw new Error(json.error);
  }
  if (json.data == null || json.data.length == 0 || (json == null ? void 0 : json.total) == 0) {
    throw new Error("No data returned");
  }
  return json.data.map(
    (citedPaperData) => parseS2paperData(citedPaperData["citedPaper"])
  );
}

// src/settingsTab.ts
var import_obsidian4 = require("obsidian");
var DEFAULT_SETTINGS = {
  NoteLocation: "",
  fileNaming: "",
  templateFileLocation: "",
  pdfDownloadLocation: "",
  openPdfAfterDownload: false,
  saveBibTex: false,
  bibTexFileLocation: "",
  noteAddFrontmatterAliases: false,
  noteAddFrontmatterAnnotation: false,
  s2apikey: "",
  pathSeparator: "",
  overridePdfs: false,
  openPdfAfterUpdate: false
};
var ObsidianScholarSettingTab = class extends import_obsidian4.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: SETTING_GENERAL_HEADER });
    let folders = this.app.vault.getAllLoadedFiles().filter((f) => f instanceof import_obsidian4.TFolder && f.path !== "/").map((f) => f.path);
    let folderOptions = {};
    folders.forEach((record) => {
      folderOptions[record] = record;
    });
    folderOptions[""] = SETTING_NOTE_FOLDER_DEFAULT;
    let pdfDownloadFolderOptions = {};
    folders.forEach((record) => {
      pdfDownloadFolderOptions[record] = record;
    });
    pdfDownloadFolderOptions[""] = SETTING_PDF_DOWNLOAD_FOLDER_DEFAULT;
    let allFiles = this.app.vault.getAllLoadedFiles().map((f) => f.path);
    let bibTexSaveOption = {};
    allFiles.forEach((record) => {
      bibTexSaveOption[record] = record;
    });
    bibTexSaveOption[""] = "";
    new import_obsidian4.Setting(containerEl).setName(SETTING_NOTE_FOLDER_NAME).setDesc(SETTING_NOTE_FOLDER_DESC).addDropdown(
      (dropdown) => dropdown.addOptions(folderOptions).setValue(this.plugin.settings.NoteLocation).onChange(async (value) => {
        this.plugin.settings.NoteLocation = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian4.Setting(containerEl).setName(SETTING_PDF_DOWNLOAD_NAME).setDesc(SETTING_PDF_DOWNLOAD_DESC).addDropdown(
      (dropdown) => dropdown.addOptions(pdfDownloadFolderOptions).setValue(this.plugin.settings.pdfDownloadLocation).onChange(async (value) => {
        this.plugin.settings.pdfDownloadLocation = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian4.Setting(containerEl).setName(SETTING_PDF_OVERRIDE_NAME).setDesc(SETTING_PDF_OVERRIDE_DESC).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.overridePdfs).onChange(async (value) => {
        this.plugin.settings.overridePdfs = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian4.Setting(containerEl).setName(SETTING_OPEN_PDF_AFTER_UPDATE_NAME).setDesc(SETTING_OPEN_PDF_AFTER_UPDATE_DESC).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.openPdfAfterUpdate).onChange(async (value) => {
        this.plugin.settings.openPdfAfterUpdate = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian4.Setting(containerEl).setName(SETTING_IS_OPEN_PDF_WITH_NOTE_NAME).setDesc(SETTING_IS_OPEN_PDF_WITH_NOTE_DESC).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.openPdfAfterDownload).onChange(async (openPdfAfterDownload) => {
        this.plugin.settings.openPdfAfterDownload = openPdfAfterDownload;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian4.Setting(containerEl).setName(SETTING_IS_ADD_TO_BIB_FILE_NAME).setDesc(SETTING_IS_ADD_TO_BIB_FILE_DESC).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.saveBibTex).onChange(async (saveBibTex) => {
        if (saveBibTex) {
          new import_obsidian4.Setting(containerEl).setName(SETTING_ADD_TO_BIB_FILE_NAME).setDesc(SETTING_ADD_TO_BIB_FILE_DESC).addDropdown(
            (dropdown) => dropdown.addOptions(bibTexSaveOption).setValue(
              this.plugin.settings.bibTexFileLocation
            ).onChange(async (value) => {
              if (!value.endsWith(".bib")) {
                new import_obsidian4.Notice(NOTICE_NOT_BIB_FILE);
              }
              if (value === "" || value === void 0 || value === null) {
                new import_obsidian4.Notice(
                  NOTICE_NO_BIB_FILE_SELECTED
                );
                return;
              }
              this.plugin.settings.bibTexFileLocation = value;
              this.plugin.settings.saveBibTex = saveBibTex;
              await this.plugin.saveSettings();
            })
          );
        } else {
          this.plugin.settings.saveBibTex = saveBibTex;
          containerEl.removeChild(containerEl.lastChild);
        }
      })
    );
    if (this.plugin.settings.saveBibTex) {
      new import_obsidian4.Setting(containerEl).setName(SETTING_ADD_TO_BIB_FILE_NAME).setDesc(SETTING_ADD_TO_BIB_FILE_DESC).addDropdown(
        (dropdown) => dropdown.addOptions(bibTexSaveOption).setValue(this.plugin.settings.bibTexFileLocation).onChange(async (value) => {
          if (!value.endsWith(".bib")) {
            new import_obsidian4.Notice(NOTICE_NOT_BIB_FILE);
          }
          this.plugin.settings.bibTexFileLocation = value;
          await this.plugin.saveSettings();
        })
      );
    }
    new import_obsidian4.Setting(containerEl).setName(SETTING_SYS_SEP).setDesc(SETTING_SYS_SEP_DESC).addText(
      (text) => text.setPlaceholder("System path separator").setValue(this.plugin.settings.pathSeparator).onChange(async (value) => {
        this.plugin.settings.pathSeparator = value;
        await this.plugin.saveSettings();
      })
    );
    containerEl.createEl("h2", { text: SETTING_NOTE_HEADER });
    new import_obsidian4.Setting(containerEl).setName(SETTING_FRONTMATTER_ADD_ALIASES_NAME).setDesc(SETTING_FRONTMATTER_ADD_ALIASES_DESC).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.noteAddFrontmatterAliases).onChange(async (value) => {
        this.plugin.settings.noteAddFrontmatterAliases = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian4.Setting(containerEl).setName(SETTING_FRONTMATTER_ADD_ANNOTATION_NAME).setDesc(SETTING_FRONTMATTER_ADD_ANNOTATION_DESC).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.noteAddFrontmatterAnnotation).onChange(async (value) => {
        this.plugin.settings.noteAddFrontmatterAnnotation = value;
        await this.plugin.saveSettings();
      })
    );
    let files = this.app.vault.getMarkdownFiles().map((file) => file.path);
    let templateOptions = {};
    files.forEach((record) => {
      templateOptions[record] = record;
    });
    templateOptions[""] = "(none)";
    new import_obsidian4.Setting(containerEl).setName(SETTING_TEMPLATE_NAME).setDesc(SETTING_TEMPLATE_DESC).addDropdown(
      (dropdown) => dropdown.addOptions(templateOptions).setValue(this.plugin.settings.templateFileLocation).onChange(async (value) => {
        this.plugin.settings.templateFileLocation = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian4.Setting(containerEl).setName(SETTING_S2API_NAME).setDesc(SETTING_S2API_DESC).addText(
      (text) => text.setPlaceholder("API key").setValue(this.plugin.settings.s2apikey || "").onChange(async (value) => {
        if (!value || value.length !== 40) {
          new import_obsidian4.Notice("Please enter a valid API key");
          return;
        }
        this.plugin.settings.s2apikey = value;
        await this.plugin.saveSettings();
      })
    );
  }
};

// src/obsidianScholar.ts
var import_obsidian5 = require("obsidian");
var import_child_process = require("child_process");
var ObsidianScholar = class {
  constructor(app, settings, pathSep) {
    this.app = app;
    this.settings = settings;
    this.pathSep = settings.pathSeparator !== "" ? this.pathSep = settings.pathSeparator : pathSep ? pathSep : "/";
  }
  constructFileName(paperData) {
    return paperData.title.replace(/[^a-zA-Z0-9 ]/g, "");
  }
  getPaperDataFromLocalFile(file) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;
    let fileCache = this.app.metadataCache.getFileCache(file);
    let frontmatter = fileCache == null ? void 0 : fileCache.frontmatter;
    let pdfPath = (_a = frontmatter == null ? void 0 : frontmatter.pdf) != null ? _a : "";
    let matchedPdfPath = pdfPath.match(/\[\[(.*?)\]\]/);
    if (matchedPdfPath) {
      pdfPath = matchedPdfPath[1];
    } else {
      pdfPath = "";
    }
    return {
      title: (_b = frontmatter == null ? void 0 : frontmatter.title) != null ? _b : file.basename,
      authors: (_c = frontmatter == null ? void 0 : frontmatter.authors.split(",")) != null ? _c : [],
      abstract: (_d = frontmatter == null ? void 0 : frontmatter.abstract) != null ? _d : null,
      url: (_e = frontmatter == null ? void 0 : frontmatter.url) != null ? _e : null,
      venue: (_f = frontmatter == null ? void 0 : frontmatter.venue) != null ? _f : null,
      publicationDate: (_g = frontmatter == null ? void 0 : frontmatter.year) != null ? _g : null,
      tags: (_h = frontmatter == null ? void 0 : frontmatter.tags) != null ? _h : [],
      pdfPath,
      citekey: (_i = frontmatter == null ? void 0 : frontmatter.citekey) != null ? _i : null,
      bibtex: (_j = frontmatter == null ? void 0 : frontmatter.bibtex) != null ? _j : null
    };
  }
  async detachAllUnpinnedLeaves() {
    const leavesToDetach = [];
    this.app.workspace.iterateRootLeaves((leaf) => {
      if (!leaf.getViewState().state.pinned) {
        leavesToDetach.push(leaf);
      }
    });
    for (const leaf of leavesToDetach) {
      try {
        leaf.detach();
        await new Promise((resolve) => setTimeout(resolve, 10));
      } catch (error) {
        console.log("Error detaching leaf:", error);
      }
    }
  }
  async getAllLocalPaperData() {
    return this.app.vault.getMarkdownFiles().filter((file) => file.path.startsWith(this.settings.NoteLocation)).map((file) => {
      return this.getPaperDataFromLocalFile(file);
    });
  }
  normalizeSearchString(str) {
    return str.toLowerCase().trim().replace(/[^\w\s]/g, "").replace(/\s+/g, " ");
  }
  fuzzyTitleMatch(paperTitle, searchTitle) {
    const normalizedPaperTitle = this.normalizeSearchString(paperTitle);
    const normalizedSearchTitle = this.normalizeSearchString(searchTitle);
    if (normalizedPaperTitle === normalizedSearchTitle) {
      return true;
    }
    if (normalizedPaperTitle.includes(normalizedSearchTitle)) {
      return true;
    }
    const paperWords = normalizedPaperTitle.split(" ");
    const searchWords = normalizedSearchTitle.split(" ");
    const matchingWords = searchWords.filter(
      (word) => paperWords.some((pWord) => pWord.includes(word))
    );
    return matchingWords.length / searchWords.length >= 0.85;
  }
  fuzzyAuthorMatch(paperAuthors, searchAuthors) {
    const normalizedSearchAuthors = this.normalizeSearchString(searchAuthors);
    const searchAuthorWords = normalizedSearchAuthors.split(" ");
    return paperAuthors.some((author) => {
      const normalizedAuthor = this.normalizeSearchString(author);
      return searchAuthorWords.some(
        (searchWord) => normalizedAuthor.includes(searchWord) && searchWord.length > 2
      );
    });
  }
  async isPaperInLibrary(searchParams) {
    let { url, title, citekey, bibstring } = searchParams;
    if (!url && !title && !citekey && !bibstring) {
      throw new Error("At least one search parameter (url, title, or citekey) must be provided");
    }
    if (bibstring) {
      const parsedBib = parseBibString(bibstring);
      if (!url && parsedBib.arxivUrl) {
        url = parsedBib.arxivUrl;
      }
      if (!url && parsedBib.url) {
        url = parsedBib.url;
      }
      if (!title && parsedBib.title) {
        title = parsedBib.title;
      }
    }
    const allPapersWithFiles = this.app.vault.getMarkdownFiles().filter((file) => file.path.startsWith(this.settings.NoteLocation)).map((file) => ({
      paperData: this.getPaperDataFromLocalFile(file),
      file
    }));
    if (url) {
      const normalizedUrl = url.toLowerCase().trim();
      for (const { paperData, file } of allPapersWithFiles) {
        if (paperData.url && paperData.url.toLowerCase().trim() === normalizedUrl) {
          return {
            isInLibrary: true,
            filePath: file.path,
            paperData
          };
        }
      }
    }
    if (citekey) {
      const normalizedCitekey = citekey.toLowerCase().trim();
      for (const { paperData, file } of allPapersWithFiles) {
        if (paperData.citekey && paperData.citekey.toLowerCase().trim() === normalizedCitekey) {
          return {
            isInLibrary: true,
            filePath: file.path,
            paperData
          };
        }
      }
    }
    if (title) {
      for (const { paperData, file } of allPapersWithFiles) {
        if (paperData.title && this.fuzzyTitleMatch(paperData.title, title)) {
          return {
            isInLibrary: true,
            filePath: file.path,
            paperData
          };
        }
      }
    }
    return { isInLibrary: false };
  }
  isFileInNoteLocation(file) {
    if (typeof file === "string") {
      return file.startsWith(this.settings.NoteLocation);
    } else {
      return file.path.startsWith(this.settings.NoteLocation);
    }
  }
  async extractPaperBibtexFromFile(citekey) {
    if (!this.settings.saveBibTex || this.settings.bibTexFileLocation === "") {
      return void 0;
    }
    let bibtextFile = this.app.vault.getAbstractFileByPath(
      this.settings.bibTexFileLocation
    );
    if (bibtextFile == null || !(bibtextFile instanceof import_obsidian5.TFile)) {
      new import_obsidian5.Notice("BibTex file not found.");
      return;
    }
    let bibtexText = await this.app.vault.adapter.read(
      this.settings.bibTexFileLocation
    );
    let bibtexEntries = splitBibtex(bibtexText);
    if (!bibtexEntries) {
      new import_obsidian5.Notice("BibTex file is empty.");
      return;
    }
    for (let entry of bibtexEntries) {
      if (entry.includes(citekey)) {
        return entry;
      }
    }
    return;
  }
  async getPaperBibtex(file) {
    if (typeof file === "string") {
      file = this.app.vault.getAbstractFileByPath(file);
    }
    let paperData = this.getPaperDataFromLocalFile(file);
    if (paperData.bibtex && paperData.bibtex !== "") {
      return paperData.bibtex;
    }
    if (paperData.citekey && paperData.citekey !== "") {
      return await this.extractPaperBibtexFromFile(paperData.citekey);
    }
  }
  cleanStringForFrontmatter(str) {
    return str.replace("\n", " ").replace(/\\[^bfnrtv0'"\\]/g, "").replace(/"/g, '\\"');
  }
  // prettier-ignore
  async createFileWithTemplate(paperData) {
    var _a;
    let template = "";
    let templateFile = this.app.vault.getAbstractFileByPath(this.settings.templateFileLocation);
    if (templateFile != null && templateFile instanceof import_obsidian5.TFile) {
      template = await this.app.vault.cachedRead(templateFile);
    } else {
      template = "---\n";
      template += NOTE_FRONTMATTER_DEFAULT;
      if (this.settings.noteAddFrontmatterAliases) {
        template += "\n" + NOTE_FRONTMATTER_ALIASES;
      }
      if (this.settings.noteAddFrontmatterAnnotation) {
        template += "\n" + NOTE_FRONTMATTER_ANNOTATION;
      }
      template += "\n---\n\n";
    }
    template = template.replace(/{{date}}/g, getDate({ format: "YYYY-MM-DD" }));
    template = template.replace(/{{time}}/g, getDate({ format: "HH:mm" }));
    template = template.replace(/{{date:(.*?)}}/g, (_, format) => getDate({ format }));
    template = template.replace(/{{time:(.*?)}}/g, (_, format) => getDate({ format }));
    template = template.replace(/{{title}}/g, this.cleanStringForFrontmatter(paperData.title));
    template = template.replace(/{{authors}}/g, this.cleanStringForFrontmatter(paperData.authors.join(", ")));
    template = template.replace(/{{abstract}}/g, this.cleanStringForFrontmatter(paperData.abstract));
    template = template.replace(/{{url}}/g, paperData.url ? this.cleanStringForFrontmatter(paperData.url) : "");
    template = template.replace(/{{venue}}/g, paperData.venue ? this.cleanStringForFrontmatter(paperData.venue) : "");
    template = template.replace(/{{tags}}/g, (_a = (paperData == null ? void 0 : paperData.tags) && this.cleanStringForFrontmatter(paperData.tags.join(", "))) != null ? _a : "");
    let publicationDate = paperData.publicationDate ? this.cleanStringForFrontmatter(paperData.publicationDate) : null;
    template = template.replace(/{{publicationDate}}/g, publicationDate ? formatTimeString(publicationDate) : "");
    template = template.replace(/{{publicationDate:(.*?)}}/g, (_, format) => publicationDate ? formatTimeString(publicationDate, format) : "");
    template = template.replace(/{{pdf}}/g, paperData.pdfPath ? `[[${paperData.pdfPath}]]` : "");
    if (paperData.citekey) {
      template = template.replace(/{{citekey}}/g, paperData.citekey);
    }
    return template;
  }
  async createFileFromPaperData(paperData, pathToFile) {
    let template = await this.createFileWithTemplate(paperData);
    if (this.settings.openPdfAfterDownload && paperData.pdfPath) {
      await this.detachAllUnpinnedLeaves();
    }
    if (await this.app.vault.adapter.exists(pathToFile)) {
      new import_obsidian5.Notice(FILE_ALREADY_EXISTS);
      this.app.workspace.openLinkText(pathToFile, pathToFile);
    } else {
      await this.app.vault.create(pathToFile, template).then(() => {
        this.app.workspace.openLinkText(pathToFile, pathToFile);
      });
    }
    if (this.settings.openPdfAfterDownload) {
      let leaf = this.app.workspace.getLeaf("split", "vertical");
      paperData.pdfPath && leaf.openFile(
        this.app.vault.getAbstractFileByPath(
          paperData.pdfPath
        )
      );
    }
  }
  async openPaper(pathToFile, paperData, shouldOpenPdf) {
    const openPdf = shouldOpenPdf !== void 0 ? shouldOpenPdf : this.settings.openPdfAfterDownload;
    if (shouldOpenPdf === void 0 && this.settings.openPdfAfterDownload) {
      await this.detachAllUnpinnedLeaves();
    }
    this.app.workspace.openLinkText(pathToFile, pathToFile);
    if (openPdf && paperData.pdfPath) {
      const noteFile = this.app.vault.getAbstractFileByPath(pathToFile);
      if (noteFile && noteFile instanceof import_obsidian5.TFile) {
        await new Promise((resolve) => setTimeout(resolve, 150));
        try {
          const pdfFile = this.app.vault.getAbstractFileByPath(paperData.pdfPath);
          if (pdfFile && pdfFile instanceof import_obsidian5.TFile) {
            const pdfLeaf = this.app.workspace.getLeaf("split", "vertical");
            await pdfLeaf.openFile(pdfFile);
          }
        } catch (error) {
          console.log("Could not open PDF in split, opening in same pane:", error);
          const pdfFile = this.app.vault.getAbstractFileByPath(paperData.pdfPath);
          if (pdfFile && pdfFile instanceof import_obsidian5.TFile) {
            const fallbackLeaf = this.app.workspace.getLeaf(true);
            await fallbackLeaf.openFile(pdfFile);
          }
        }
      }
    }
  }
  async downloadPdf(pdfUrl, filename) {
    return new Promise(async (resolve, reject) => {
      if (!pdfUrl) {
        reject("pdfUrl is undefined or null");
        return;
      }
      let pdfDownloadFolder = this.settings.pdfDownloadLocation;
      let pdfSavePath = pdfDownloadFolder + this.pathSep + filename + ".pdf";
      if (await this.app.vault.adapter.exists(pdfSavePath)) {
        resolve(pdfSavePath);
        return;
      }
      (0, import_obsidian5.requestUrl)({
        url: pdfUrl,
        method: "GET"
      }).arrayBuffer.then((arrayBuffer) => {
        this.app.vault.createBinary(pdfSavePath, arrayBuffer).then(() => resolve(pdfSavePath)).catch(reject);
      }).catch(reject);
    });
  }
  async openPdfWithSystemViewer(currentFile) {
    if (!import_obsidian5.Platform.isMacOS) {
      new import_obsidian5.Notice("This feature is only available on macOS.");
      return;
    }
    let pdfPath = "";
    if (currentFile.extension == "md" && this.isFileInNoteLocation(currentFile)) {
      let paperData = this.getPaperDataFromLocalFile(currentFile);
      if (paperData.pdfPath) {
        pdfPath = paperData.pdfPath;
      }
    } else if (currentFile.extension == "pdf") {
      pdfPath = currentFile.path;
    } else {
      new import_obsidian5.Notice("The current file is not a pdf or a note.");
      return;
    }
    if (pdfPath === "" || !pdfPath) {
      new import_obsidian5.Notice("No pdf path found.");
      return;
    }
    let absolutePath = this.app.vault.adapter.getFullPath(pdfPath);
    (0, import_child_process.exec)(`open "${absolutePath}"`, (error, stdout, stderr) => {
      if (error) {
        console.error(`exec error: ${error}`);
        return;
      }
    });
  }
  async saveBibTex(bibtex) {
    if (this.settings.saveBibTex === false) {
      return;
    }
    let bibTexPath = this.settings.bibTexFileLocation;
    if (bibTexPath === "") {
      new import_obsidian5.Notice("BibTex location is not set in the settings.");
      return;
    }
    let bibtexText = "";
    if (await this.app.vault.adapter.exists(bibTexPath)) {
      let bibtexText2 = await this.app.vault.adapter.read(bibTexPath);
      if (bibtexText2.includes(bibtex)) {
        new import_obsidian5.Notice("BibTex entry already exists.");
        return;
      }
    }
    let bibtextFile = this.app.vault.getAbstractFileByPath(bibTexPath);
    if (bibtextFile == null || !(bibtextFile instanceof import_obsidian5.TFile)) {
      new import_obsidian5.Notice("BibTex file not found.");
      return;
    }
    this.app.vault.append(bibtextFile, bibtex + "\n\n" + bibtexText).then(() => {
      new import_obsidian5.Notice("BibTex entry saved.");
    }).catch((error) => {
      new import_obsidian5.Notice("Error: " + error);
    });
  }
  async downloadAndSavePaperNotePDF(paperData) {
    let paperFilename = this.constructFileName(paperData);
    if (!paperData.pdfUrl) {
      new import_obsidian5.Notice(
        "No pdf url found. You might need to find the PDF manually."
      );
    } else {
      paperData.pdfPath = await this.downloadPdf(
        paperData.pdfUrl,
        paperFilename
      );
    }
    let pathToFile = this.settings.NoteLocation + this.pathSep + paperFilename + ".md";
    await this.createFileFromPaperData(paperData, pathToFile);
    (paperData == null ? void 0 : paperData.bibtex) && await this.saveBibTex(paperData.bibtex);
  }
  async removePaperFromPath(pathsToFile) {
    let citeKeysToRemove = [];
    for (let pathToFile of pathsToFile) {
      if (await this.app.vault.adapter.exists(pathToFile)) {
        let noteFile = this.app.vault.getAbstractFileByPath(pathToFile);
        if (noteFile == null || !(noteFile instanceof import_obsidian5.TFile)) {
          new import_obsidian5.Notice("Note file not found.");
          return;
        }
        let paperData = this.getPaperDataFromLocalFile(noteFile);
        if (paperData.citekey) {
          citeKeysToRemove.push(paperData.citekey);
        }
        if (paperData.pdfPath) {
          let pdfFile = this.app.vault.getAbstractFileByPath(
            paperData.pdfPath
          );
          if (pdfFile == null || !(pdfFile instanceof import_obsidian5.TFile)) {
            new import_obsidian5.Notice("PDF file not found.");
            return;
          }
          await this.app.vault.delete(pdfFile);
        }
        await this.app.vault.delete(noteFile);
        new import_obsidian5.Notice(
          "Paper " + paperData.title + "removed from the library."
        );
      } else {
        new import_obsidian5.Notice("File" + pathToFile + "not found.");
      }
    }
    if (this.settings.bibTexFileLocation) {
      let bibTexPath = this.settings.bibTexFileLocation;
      let bibtextFile = this.app.vault.getAbstractFileByPath(bibTexPath);
      if (bibtextFile == null || !(bibtextFile instanceof import_obsidian5.TFile)) {
        new import_obsidian5.Notice("BibTex file not found.");
        return;
      }
      let bibtexText = await this.app.vault.adapter.read(
        this.settings.bibTexFileLocation
      );
      let bibtexEntries = splitBibtex(bibtexText);
      if (!bibtexEntries) {
        new import_obsidian5.Notice("BibTex file is empty.");
        return;
      }
      bibtexEntries = bibtexEntries.filter(
        (entry) => !citeKeysToRemove.some((citekey) => entry.includes(citekey))
      );
      let newBibtexText = bibtexEntries.join("\n\n");
      await this.app.vault.adapter.write(
        this.settings.bibTexFileLocation,
        newBibtexText
      );
    }
  }
  async copyLocalPdfToLibrary(localPdfPath, targetFilename) {
    return new Promise(async (resolve, reject) => {
      try {
        if (!import_obsidian5.Platform.isDesktop) {
          reject("Local file copying is only available on desktop platforms. Please use URL downloads on mobile.");
          return;
        }
        const { promises: fs } = await import("fs");
        const { join } = await import("path");
        const { homedir } = await import("os");
        let pdfDownloadFolder = this.settings.pdfDownloadLocation;
        let pdfSavePath = pdfDownloadFolder + this.pathSep + targetFilename + ".pdf";
        if (await this.app.vault.adapter.exists(pdfSavePath)) {
          resolve(pdfSavePath);
          return;
        }
        let sourceBinary;
        const isAbsolutePath = localPdfPath.startsWith("/") || localPdfPath.startsWith("\\") || localPdfPath.match(/^[A-Za-z]:/);
        let expandedPath = localPdfPath;
        if (localPdfPath.startsWith("~/")) {
          expandedPath = join(homedir(), localPdfPath.slice(2));
        }
        if (isAbsolutePath || expandedPath !== localPdfPath) {
          try {
            await fs.access(expandedPath);
            const fileBuffer = await fs.readFile(expandedPath);
            sourceBinary = fileBuffer.buffer.slice(fileBuffer.byteOffset, fileBuffer.byteOffset + fileBuffer.byteLength);
          } catch (error) {
            reject("Source PDF file not found or cannot be accessed: " + expandedPath);
            return;
          }
        } else {
          if (!await this.app.vault.adapter.exists(localPdfPath)) {
            reject("Source PDF file not found in vault: " + localPdfPath);
            return;
          }
          sourceBinary = await this.app.vault.adapter.readBinary(localPdfPath);
        }
        await this.app.vault.createBinary(pdfSavePath, sourceBinary);
        resolve(pdfSavePath);
      } catch (error) {
        reject("Failed to copy PDF: " + error);
      }
    });
  }
  async updateNotePdfPath(notePath, pdfPath) {
    try {
      let noteFile = this.app.vault.getAbstractFileByPath(notePath);
      if (noteFile == null || !(noteFile instanceof import_obsidian5.TFile)) {
        throw new Error("Note file not found.");
      }
      let content = await this.app.vault.read(noteFile);
      let frontmatterMatch = content.match(/^---\n([\s\S]*?)\n---/);
      if (!frontmatterMatch) {
        throw new Error("No frontmatter found in note.");
      }
      let frontmatterContent = frontmatterMatch[1];
      let bodyContent = content.slice(frontmatterMatch[0].length);
      let frontmatterLines = frontmatterContent.split("\n");
      let pdfLinkFormat = `[[${pdfPath}]]`;
      let pdfLineFound = false;
      for (let i = 0; i < frontmatterLines.length; i++) {
        if (frontmatterLines[i].match(/^pdf:\s*/)) {
          frontmatterLines[i] = `pdf: "${pdfLinkFormat}"`;
          pdfLineFound = true;
          break;
        }
      }
      if (!pdfLineFound) {
        frontmatterLines.push(`pdf: "${pdfLinkFormat}"`);
      }
      let newFrontmatterContent = frontmatterLines.join("\n");
      let newContent = `---
${newFrontmatterContent}
---${bodyContent}`;
      await this.app.vault.modify(noteFile, newContent);
      new import_obsidian5.Notice("PDF path updated successfully.");
    } catch (error) {
      new import_obsidian5.Notice("Failed to update note: " + error);
      throw error;
    }
  }
  async addPdfToPaper(notePath, pdfSource) {
    try {
      let noteFile = this.app.vault.getAbstractFileByPath(notePath);
      if (noteFile == null || !(noteFile instanceof import_obsidian5.TFile)) {
        throw new Error("Note file not found.");
      }
      let paperData = this.getPaperDataFromLocalFile(noteFile);
      let paperFilename = this.constructFileName(paperData);
      let pdfPath;
      if (paperData.pdfPath) {
        if (this.settings.overridePdfs) {
          await this.removeExistingPdf(paperData.pdfPath);
        } else {
          await this.createPdfBackup(paperData.pdfPath);
          await this.removeExistingPdf(paperData.pdfPath);
        }
      }
      if (pdfSource.startsWith("http://") || pdfSource.startsWith("https://")) {
        pdfPath = await this.downloadPdf(pdfSource, paperFilename);
      } else {
        pdfPath = await this.copyLocalPdfToLibrary(pdfSource, paperFilename);
      }
      await this.updateNotePdfPath(notePath, pdfPath);
      const updatedPaperData = this.getPaperDataFromLocalFile(noteFile);
      if (this.settings.openPdfAfterUpdate) {
        await this.openPaper(notePath, updatedPaperData, true);
      }
    } catch (error) {
      new import_obsidian5.Notice("Failed to add PDF to paper: " + error);
      throw error;
    }
  }
  async createPdfBackup(existingPdfPath) {
    try {
      if (!await this.app.vault.adapter.exists(existingPdfPath)) {
        return;
      }
      const now = /* @__PURE__ */ new Date();
      const timestamp = now.getFullYear().toString() + "." + (now.getMonth() + 1).toString().padStart(2, "0") + "." + now.getDate().toString().padStart(2, "0") + "." + now.getHours().toString().padStart(2, "0") + "." + now.getMinutes().toString().padStart(2, "0");
      const pathParts = existingPdfPath.split(this.pathSep);
      const fileName = pathParts[pathParts.length - 1];
      const fileNameWithoutExt = fileName.replace(/\.pdf$/i, "");
      const directory = pathParts.slice(0, -1).join(this.pathSep);
      const backupFileName = `${fileNameWithoutExt}.backup.${timestamp}.pdf`;
      const backupPath = directory + this.pathSep + backupFileName;
      const existingPdfData = await this.app.vault.adapter.readBinary(existingPdfPath);
      await this.app.vault.createBinary(backupPath, existingPdfData);
      new import_obsidian5.Notice(`PDF backup created: ${backupFileName}`);
    } catch (error) {
      new import_obsidian5.Notice("Failed to create PDF backup: " + error);
      throw error;
    }
  }
  async removeExistingPdf(existingPdfPath) {
    try {
      if (!await this.app.vault.adapter.exists(existingPdfPath)) {
        return;
      }
      const existingPdfFile = this.app.vault.getAbstractFileByPath(existingPdfPath);
      if (existingPdfFile && existingPdfFile instanceof import_obsidian5.TFile) {
        await this.app.vault.delete(existingPdfFile);
        new import_obsidian5.Notice("Existing PDF removed.");
      }
    } catch (error) {
      new import_obsidian5.Notice("Failed to remove existing PDF: " + error);
      throw error;
    }
  }
};

// src/obsidianScholarApi.ts
var ObsidianScholarApi = class {
  static GetApi(app, plugin, scholar, paperSearchModalClass) {
    return {
      // Paper creation and management
      createPaperNoteFromUrl: async (url) => {
        return this.createPaperNoteFromUrl(app, plugin, scholar, url);
      },
      // Paper library checking
      isPaperInLibrary: async (searchParams) => {
        return scholar.isPaperInLibrary(searchParams);
      },
      // Paper search with title - opens the paper search modal with pre-filled title or creates paper note from URL
      openPaper: async (searchParams) => {
        return this.openPaper(app, plugin, scholar, searchParams, paperSearchModalClass);
      }
      // Convenience method for URL-only searches
      // findPaperByUrl: async (url: string): Promise<PaperLibraryCheckResult> => {
      // 	if (!isValidUrl(url)) {
      // 		throw new Error("Invalid URL");
      // 	}
      // 	return scholar.isPaperInLibrary({ url });
      // },
    };
  }
  static async createPaperNoteFromUrl(app, plugin, scholar, url) {
    if (!isValidUrl(url)) {
      throw new Error("Invalid URL");
    }
    try {
      const paperData = await this.fetchPaperMetadata(app, plugin, url);
      await scholar.downloadAndSavePaperNotePDF(paperData);
    } catch (error) {
      console.error("Failed to create paper note:", error);
      throw error;
    }
  }
  static async fetchPaperMetadata(app, plugin, url) {
    let paperFetchFunction;
    if (url.includes("arxiv.org")) {
      paperFetchFunction = fetchArxivPaperDataFromUrl;
    } else {
      paperFetchFunction = (url2) => fetchSemanticScholarPaperDataFromUrl(
        url2,
        plugin.settings.s2apikey
      );
    }
    return await paperFetchFunction(url);
  }
  /**
   * Opens the paper search modal with a pre-filled query or creates paper note from URL
   * @param app - The Obsidian app instance
   * @param plugin - The plugin instance
   * @param scholar - The ObsidianScholar instance
   * @param searchParams - The search parameters (title, bibstring, and/or url)
   * @param paperSearchModalClass - The modal class to instantiate
   */
  static async openPaper(app, plugin, scholar, searchParams, paperSearchModalClass) {
    if (!searchParams || !searchParams.title && !searchParams.bibstring && !searchParams.url) {
      throw new Error("At least one search parameter (title, bibstring, or url) must be provided");
    }
    if (searchParams.url) {
      await this.createPaperNoteFromUrl(app, plugin, scholar, searchParams.url);
      return;
    }
    if (searchParams.title) {
      this.openSearchModal(app, plugin, scholar, searchParams.title, paperSearchModalClass);
      return;
    }
    if (searchParams.bibstring) {
      const parsedBib = parseBibString(searchParams.bibstring);
      if (parsedBib.arxivUrl || parsedBib.url) {
        const url = parsedBib.arxivUrl || parsedBib.url;
        if (url) {
          await this.createPaperNoteFromUrl(app, plugin, scholar, url);
          return;
        }
      }
      const queryText = parsedBib.title || searchParams.bibstring;
      this.openSearchModal(app, plugin, scholar, queryText, paperSearchModalClass);
      return;
    }
  }
  /**
   * Helper method to open the paper search modal with a pre-filled query
   */
  static openSearchModal(app, plugin, scholar, queryText, paperSearchModalClass) {
    if (!paperSearchModalClass) {
      throw new Error("Paper search modal class not provided");
    }
    const modal = new paperSearchModalClass(
      app,
      plugin.settings,
      scholar,
      queryText.trim()
    );
    modal.open();
  }
};

// src/main.ts
var ObsidianScholarPlugin = class extends import_obsidian6.Plugin {
  get api() {
    return ObsidianScholarApi.GetApi(this.app, this, this.obsidianScholar, paperSearchModal);
  }
  async onload() {
    await this.loadSettings();
    this.obsidianScholar = new ObsidianScholar(
      this.app,
      this.settings,
      getSystemPathSeparator()
    );
    this.addCommand({
      id: COMMAND_PAPER_NOTE_ID,
      name: COMMAND_PAPER_NOTE_NAME,
      callback: () => {
        new createNoteFromUrlModal(
          this.app,
          this.settings,
          this.obsidianScholar
        ).open();
      }
    });
    this.addCommand({
      id: COMMAND_SEARCH_PAPER,
      name: COMMAND_SEARCH_PAPER_NAME,
      callback: () => {
        new paperSearchModal(
          this.app,
          this.settings,
          this.obsidianScholar
        ).open();
      }
    });
    this.addCommand({
      id: COMMAND_COPY_PAPER_BIBTEX,
      name: COMMAND_COPY_PAPER_BIBTEX_NAME,
      checkCallback: (checking) => {
        const currentFile = this.app.workspace.getActiveFile();
        if (!this.settings.saveBibTex || !currentFile || currentFile.extension !== "md" || !this.obsidianScholar.isFileInNoteLocation(currentFile)) {
          return false;
        } else {
          if (!checking) {
            this.obsidianScholar.getPaperBibtex(currentFile).then((bibtex) => {
              if (!bibtex) {
                new import_obsidian6.Notice(NOTICE_SEARCH_BIBTEX_NOT_FOUND);
                return false;
              }
              navigator.clipboard.writeText(bibtex);
              new import_obsidian6.Notice(NOTICE_SEARCH_BIBTEX_COPIED);
            }).catch((err) => {
              console.log(err);
              new import_obsidian6.Notice(NOTICE_SEARCH_BIBTEX_ERROR);
            });
          }
          return true;
        }
      }
    });
    this.addCommand({
      id: COMMAND_SEARCH_PAPER_REFERENCES,
      name: COMMAND_SEARCH_PAPER_REFERENCES_NAME,
      checkCallback: (checking) => {
        const currentFile = this.app.workspace.getActiveFile();
        if (!currentFile || currentFile.extension !== "md" || !this.obsidianScholar.isFileInNoteLocation(currentFile)) {
          return false;
        } else {
          if (!checking) {
            let paperData = this.obsidianScholar.getPaperDataFromLocalFile(
              currentFile
            );
            if (paperData && paperData.url) {
              fetchSemanticScholarPaperReferences(
                paperData.url
              ).then((references) => {
                new paperReferenceSearchModal(
                  this.app,
                  this.settings,
                  this.obsidianScholar,
                  references.map((reference, index) => {
                    return {
                      paper: reference,
                      paperIndex: index,
                      resultType: "semanticscholar",
                      s2Url: reference.url
                    };
                  }),
                  "Check References for " + paperData.title
                ).open();
              });
            }
          }
          return true;
        }
      }
    });
    this.addCommand({
      id: COMMAND_REMOVE_PAPER,
      name: COMMAND_REMOVE_PAPER_NAME,
      callback: () => {
        const currentFile = this.app.workspace.getActiveFile();
        new paperRemoveModal(
          this.app,
          this.settings,
          this.obsidianScholar,
          currentFile
        ).open();
      }
    });
    this.addCommand({
      id: COMMAND_OPEN_PDF_IN_SYSTEM_APP,
      name: COMMAND_OPEN_PDF_IN_SYSTEM_APP_NAME,
      checkCallback: (checking) => {
        const currentFile = this.app.workspace.getActiveFile();
        if (!currentFile || !import_obsidian6.Platform.isMacOS) {
          return false;
        } else {
          if (!checking) {
            this.obsidianScholar.openPdfWithSystemViewer(
              currentFile
            );
          }
          return true;
        }
      }
    });
    this.addCommand({
      id: COMMAND_ADD_PAPER_PDF,
      name: COMMAND_ADD_PAPER_PDF_NAME,
      callback: () => {
        new addPaperPdfModal(
          this.app,
          this.settings,
          this.obsidianScholar
        ).open();
      }
    });
    this.addSettingTab(new ObsidianScholarSettingTab(this.app, this));
    this.registerExtensions(["bib"], "markdown");
    this.registerExtensions(["tex"], "markdown");
    this.addRibbonIcon("library-big", "Open Scholar Library", () => {
      new paperSearchModal(
        this.app,
        this.settings,
        this.obsidianScholar
      ).open();
    });
    this.addRibbonIcon("book-plus", "Add to Scholar Library", () => {
      new createNoteFromUrlModal(
        this.app,
        this.settings,
        this.obsidianScholar
      ).open();
    });
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign(
      {},
      DEFAULT_SETTINGS,
      await this.loadData()
    );
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
var paperSearchModal = class extends import_obsidian6.SuggestModal {
  constructor(app, settings, obsidianScholar, initialQuery) {
    super(app);
    this.lastSearchResults = [];
    this.localPaperData = [];
    this.settings = settings;
    this.obsidianScholar = obsidianScholar;
    const instructions = [
      ["\u2191\u2193", "to navigate"],
      ["\u21B5", "to open"],
      ["shift \u21B5", "to search semanticscholar"],
      ["\u21E5 (tab)", "to expand search result"],
      ["esc", "to dismiss"]
    ];
    const modalInstructionsHTML = this.modalEl.createEl("div", {
      cls: "prompt-instructions"
    });
    for (const instruction of instructions) {
      const modalInstructionHTML = modalInstructionsHTML.createDiv({
        cls: "prompt-instruction"
      });
      modalInstructionHTML.createSpan({
        cls: "prompt-instruction-command",
        text: instruction[0]
      });
      modalInstructionHTML.createSpan({ text: instruction[1] });
    }
    this.setPlaceholder("Enter paper Name");
    this.localPaperData = this.app.vault.getMarkdownFiles().filter((file) => file.path.startsWith(this.settings.NoteLocation)).map((file, index) => {
      return {
        paper: this.obsidianScholar.getPaperDataFromLocalFile(file),
        resultType: "local",
        localFilePath: file.path,
        paperIndex: index
      };
    });
    if (initialQuery) {
      this.initialQuery = initialQuery;
    }
  }
  searchLocalPapers(query) {
    let results = this.localPaperData.filter((paper) => {
      return paper.paper.title.toLowerCase().contains(query.toLowerCase()) || paper.paper.authors.map((author) => author.toLowerCase()).some((author) => author.contains(query.toLowerCase()));
    });
    return results;
  }
  async searchSemanticScholar(query) {
    let searchResult = [];
    try {
      searchResult = await searchSemanticScholar(
        query,
        this.settings.s2apikey
      );
    } catch (error) {
      new import_obsidian6.Notice("Errors when downloading papers from Semanticscholar");
      console.error(error);
    }
    this.lastSearchResults = searchResult.map((paper, index) => {
      return {
        paper,
        paperIndex: index + this.localPaperData.length,
        resultType: "semanticscholar",
        s2Url: paper.url,
        isFirstS2Result: index === 0
      };
    });
    this.updateSuggestions();
  }
  onOpen() {
    this.keyListener = async (event) => {
      if (event.repeat)
        return;
      if (event.shiftKey && event.key === "Enter") {
        const inputEl = document.querySelector(
          ".prompt-input"
        );
        const query = inputEl.value;
        await this.searchSemanticScholar(query);
      }
      if (event.shiftKey && event.key === "Tab") {
        const selectedItem = document.querySelector(
          ".suggestion-item.is-selected"
        );
        if (selectedItem) {
          selectedItem.classList.toggle("is-added");
        }
      }
      if (!event.shiftKey && event.key === "Tab") {
        const abstractHTML = document.querySelector(
          ".suggestion-item.is-selected > .paper-search-result-abstract"
        );
        if (abstractHTML) {
          abstractHTML.classList.toggle("is-show");
        }
      }
    };
    document.addEventListener("keydown", this.keyListener);
    super.onOpen();
    if (this.initialQuery) {
      const inputEl = document.querySelector(
        ".prompt-input"
      );
      if (inputEl) {
        inputEl.value = this.initialQuery;
        const title = this.initialQuery;
        const foundInLibrary = this.localPaperData.some(
          (item) => this.obsidianScholar.fuzzyTitleMatch(item.paper.title, title)
        );
        if (!foundInLibrary) {
          this.searchSemanticScholar(this.initialQuery);
        }
      }
    }
  }
  getSuggestions(query) {
    if (query.trim() === "") {
      return this.localPaperData;
    }
    let result = [];
    let localResults = this.searchLocalPapers(query);
    result = result.concat(localResults);
    result = result.concat(this.lastSearchResults);
    return result;
  }
  renderSuggestion(searchResult, el) {
    if (searchResult.resultType === "semanticscholar") {
      if (searchResult.isFirstS2Result) {
        el.createEl("div", {
          text: "SemanticScholar Search Results",
          cls: "paper-search-result-heading"
        });
      }
    }
    el.createEl("div", {
      text: searchResult.paper.title,
      cls: "paper-search-result-title",
      attr: {
        "data-paper-id": searchResult.paperIndex
      }
    });
    el.createEl("div", {
      text: searchResult.paper.authors.join(", "),
      cls: "paper-search-result-authors"
    });
    el.createEl("div", {
      text: searchResult.paper.abstract,
      cls: "paper-search-result-abstract"
    });
  }
  onChooseSuggestion(searchResult, evt) {
    let allSelectedPaperIds = [];
    this.resultContainerEl.querySelectorAll(".is-added").forEach((el) => {
      let titleEl = el.querySelector(".paper-search-result-title");
      if (titleEl) {
        let paperId = titleEl.getAttribute(
          "data-paper-id"
        );
        if (paperId) {
          allSelectedPaperIds.push(parseInt(paperId));
        }
      }
    });
    console.log(allSelectedPaperIds);
    if (allSelectedPaperIds.length > 0) {
      let papersToDownload = this.lastSearchResults.filter(
        (searchResult2) => {
          return allSelectedPaperIds.includes(
            searchResult2.paperIndex
          );
        }
      );
      console.log(papersToDownload);
      papersToDownload.forEach((searchResult2, index) => {
        new import_obsidian6.Notice(
          "Downloading paper " + (index + 1) + " of " + papersToDownload.length
        );
        this.obsidianScholar.downloadAndSavePaperNotePDF(
          searchResult2.paper
        );
      });
    } else {
      if (searchResult.resultType === "local") {
        const localFilePath = searchResult.localFilePath;
        if (localFilePath) {
          this.obsidianScholar.openPaper(
            localFilePath,
            searchResult.paper
          );
        } else {
          new import_obsidian6.Notice("Local file path not found");
        }
      } else {
        const s2Url = searchResult.s2Url;
        if (s2Url) {
          new import_obsidian6.Notice(NOTICE_DOWNLOADING_S2);
          this.obsidianScholar.downloadAndSavePaperNotePDF(
            searchResult.paper
          );
        } else {
          new import_obsidian6.Notice("S2 URL not found");
        }
      }
    }
  }
  onNoSuggestion() {
    this.resultContainerEl.empty();
  }
  onClose() {
    document.removeEventListener("keydown", this.keyListener);
  }
};
var paperReferenceSearchModal = class extends import_obsidian6.SuggestModal {
  constructor(app, settings, obsidianScholar, currentPapers, headline) {
    super(app);
    this.settings = settings;
    this.obsidianScholar = obsidianScholar;
    this.currentSearchResults = currentPapers;
    const instructions = [
      ["\u2191\u2193", "to navigate"],
      ["\u21B5", "to open"],
      ["\u21E5 (tab)", "to expand search result"],
      ["\u21E7 \u21E5", "to add paper to selection"],
      ["esc", "to dismiss"]
    ];
    const modalInstructionsHTML = this.modalEl.createEl("div", {
      cls: "prompt-instructions"
    });
    for (const instruction of instructions) {
      const modalInstructionHTML = modalInstructionsHTML.createDiv({
        cls: "prompt-instruction"
      });
      modalInstructionHTML.createSpan({
        cls: "prompt-instruction-command",
        text: instruction[0]
      });
      modalInstructionHTML.createSpan({ text: instruction[1] });
    }
    this.setPlaceholder(headline);
  }
  onOpen() {
    this.keyListener = async (event) => {
      if (event.repeat)
        return;
      if (event.shiftKey && event.key === "Tab") {
        const selectedItem = document.querySelector(
          ".suggestion-item.is-selected"
        );
        if (selectedItem) {
          selectedItem.classList.toggle("is-added");
        }
      }
      if (!event.shiftKey && event.key === "Tab") {
        const abstractHTML = document.querySelector(
          ".suggestion-item.is-selected > .paper-search-result-abstract"
        );
        if (abstractHTML) {
          abstractHTML.classList.toggle("is-show");
        }
      }
    };
    document.addEventListener("keydown", this.keyListener);
    super.onOpen();
  }
  getSuggestions(query) {
    if (query.trim() === "") {
      return this.currentSearchResults;
    } else {
      let results = this.currentSearchResults.filter((searchResult) => {
        return searchResult.paper.title.toLowerCase().contains(query.toLowerCase()) || searchResult.paper.authors.map((author) => author.toLowerCase()).some((author) => author.contains(query.toLowerCase()));
      });
      return results;
    }
  }
  renderSuggestion(searchResult, el) {
    el.createEl("div", {
      text: searchResult.paper.title,
      cls: "paper-search-result-title",
      attr: { "data-paper-id": searchResult.paperIndex }
    });
    el.createEl("div", {
      text: searchResult.paper.authors.join(", "),
      cls: "paper-search-result-authors"
    });
    el.createEl("div", {
      text: searchResult.paper.abstract,
      cls: "paper-search-result-abstract"
    });
  }
  onChooseSuggestion(searchResult, evt) {
    let allSelectedPaperIds = [];
    this.resultContainerEl.querySelectorAll(".is-added").forEach((el) => {
      if (el.firstChild) {
        let paperId = el.firstChild.getAttribute(
          "data-paper-id"
        );
        if (paperId) {
          allSelectedPaperIds.push(parseInt(paperId));
        }
      }
    });
    if (allSelectedPaperIds.length > 0) {
      let papersToDownload = this.currentSearchResults.filter(
        (searchResult2) => {
          return allSelectedPaperIds.includes(
            searchResult2.paperIndex
          );
        }
      );
      papersToDownload.forEach((searchResult2, index) => {
        new import_obsidian6.Notice(
          "Downloading paper " + (index + 1) + " of " + papersToDownload.length
        );
        this.obsidianScholar.downloadAndSavePaperNotePDF(
          searchResult2.paper
        );
      });
    } else {
      this.obsidianScholar.downloadAndSavePaperNotePDF(
        searchResult.paper
      );
    }
  }
  onNoSuggestion() {
    this.resultContainerEl.empty();
  }
  onClose() {
    document.removeEventListener("keydown", this.keyListener);
  }
};
var paperRemoveModal = class extends import_obsidian6.SuggestModal {
  constructor(app, settings, obsidianScholar, currentFile) {
    super(app);
    this.localPaperData = [];
    this.settings = settings;
    this.obsidianScholar = obsidianScholar;
    this.currentFile = currentFile;
    const instructions = [
      ["\u2191\u2193", "to navigate"],
      ["\u21B5", "to open"],
      ["\u21E5 (tab)", "to expand search result"],
      ["\u21E7 \u21E5", "to add paper to selection"],
      ["esc", "to dismiss"]
    ];
    const modalInstructionsHTML = this.modalEl.createEl("div", {
      cls: "prompt-instructions"
    });
    for (const instruction of instructions) {
      const modalInstructionHTML = modalInstructionsHTML.createDiv({
        cls: "prompt-instruction"
      });
      modalInstructionHTML.createSpan({
        cls: "prompt-instruction-command",
        text: instruction[0]
      });
      modalInstructionHTML.createSpan({ text: instruction[1] });
    }
    this.setPlaceholder("Type paper to remove");
    this.localPaperData = this.app.vault.getMarkdownFiles().filter((file) => file.path.startsWith(this.settings.NoteLocation)).map((file, index) => {
      return {
        paper: this.obsidianScholar.getPaperDataFromLocalFile(file),
        resultType: "local",
        localFilePath: file.path,
        paperIndex: index
      };
    });
    if (currentFile != null) {
      if (this.localPaperData.some(
        (paper) => paper.localFilePath === currentFile.path
      )) {
        let currentPaper = this.localPaperData.find(
          (paper) => paper.localFilePath === currentFile.path
        );
        if (currentPaper === void 0) {
          throw new Error(
            "Current paper not found in local paper data"
          );
        }
        this.localPaperData = [
          currentPaper,
          ...this.localPaperData.filter(
            (paper) => paper.localFilePath !== currentFile.path
          )
        ];
      }
    }
  }
  searchLocalPapers(query) {
    let results = this.localPaperData.filter((paper) => {
      return paper.paper.title.toLowerCase().contains(query.toLowerCase()) || paper.paper.authors.map((author) => author.toLowerCase()).some((author) => author.contains(query.toLowerCase()));
    });
    return results;
  }
  onOpen() {
    this.keyListener = async (event) => {
      if (event.repeat)
        return;
      if (event.shiftKey && event.key === "Tab") {
        const selectedItem = document.querySelector(
          ".suggestion-item.is-selected"
        );
        if (selectedItem) {
          selectedItem.classList.toggle("is-added");
        }
      }
      if (!event.shiftKey && event.key === "Tab") {
        const abstractHTML = document.querySelector(
          ".suggestion-item.is-selected > .paper-search-result-abstract"
        );
        if (abstractHTML) {
          abstractHTML.classList.toggle("is-show");
        }
      }
    };
    document.addEventListener("keydown", this.keyListener);
    super.onOpen();
  }
  getSuggestions(query) {
    if (query.trim() === "") {
      return this.localPaperData;
    }
    let result = [];
    let localResults = this.searchLocalPapers(query);
    result = result.concat(localResults);
    return result;
  }
  renderSuggestion(searchResult, el) {
    el.createEl("div", {
      text: searchResult.paper.title,
      cls: "paper-search-result-title",
      attr: {
        "data-paper-id": searchResult.paperIndex
      }
    });
    el.createEl("div", {
      text: searchResult.paper.authors.join(", "),
      cls: "paper-search-result-authors"
    });
    el.createEl("div", {
      text: searchResult.paper.abstract,
      cls: "paper-search-result-abstract"
    });
  }
  onChooseSuggestion(searchResult, evt) {
    let allSelectedPaperIds = [];
    this.resultContainerEl.querySelectorAll(".is-added").forEach((el) => {
      if (el.firstChild) {
        let paperId = el.firstChild.getAttribute(
          "data-paper-id"
        );
        if (paperId) {
          allSelectedPaperIds.push(parseInt(paperId));
        }
      }
    });
    if (allSelectedPaperIds.length > 0) {
      let papersToRemove = this.localPaperData.filter((searchResult2) => {
        return allSelectedPaperIds.includes(searchResult2.paperIndex);
      });
      new confirmDeleteModal(
        this.app,
        this.settings,
        this.obsidianScholar,
        papersToRemove.map((paper) => paper.localFilePath).filter(
          (path) => path !== void 0
        )
      ).open();
    } else {
      const localFilePath = searchResult.localFilePath;
      if (localFilePath) {
        new import_obsidian6.Notice("Removing papers from library");
        new confirmDeleteModal(
          this.app,
          this.settings,
          this.obsidianScholar,
          [localFilePath]
        ).open();
      } else {
        new import_obsidian6.Notice("Local file path not found");
      }
    }
  }
  onNoSuggestion() {
    this.resultContainerEl.empty();
  }
  onClose() {
    document.removeEventListener("keydown", this.keyListener);
  }
};
var confirmDeleteModal = class extends import_obsidian6.Modal {
  constructor(app, settings, obsidianScholar, paperPaths) {
    super(app);
    this.settings = settings;
    this.obsidianScholar = obsidianScholar;
    this.paperPaths = paperPaths;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h1", {
      text: "Are you sure to remove the following papers?"
    });
    const paperList = contentEl.createEl("ul");
    this.paperPaths.forEach((paperPath) => {
      paperList.createEl("li", { text: paperPath });
    });
    new import_obsidian6.Setting(contentEl).addButton(
      (btn) => btn.setButtonText("No").onClick(() => {
        this.close();
      })
    ).addButton(
      (btn) => btn.setButtonText("Yes").setWarning().onClick(() => {
        this.close();
        this.obsidianScholar.removePaperFromPath(
          this.paperPaths
        );
      })
    );
  }
  onClose() {
    let { contentEl } = this;
    contentEl.empty();
  }
};
var createNoteFromUrlModal = class extends import_obsidian6.Modal {
  constructor(app, settings, obsidianScholar) {
    super(app);
    this.settings = settings;
    this.obsidianScholar = obsidianScholar;
  }
  addInputElementToModal(type) {
    const { contentEl } = this;
    let input = contentEl.createEl(type);
    return input;
  }
  addPropertyToElement(element, property, value) {
    element.setAttribute(property, value);
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h4", {
      text: COMMAND_PAPER_MODAL_TITLE,
      cls: "add-paper-title"
    });
    let placeholder = COMMAND_PAPER_MODAL_PLACEHOLDERS[Math.floor(
      Math.random() * COMMAND_PAPER_MODAL_PLACEHOLDERS.length
    )];
    let input = this.addInputElementToModal("input");
    this.addPropertyToElement(input, "type", "search");
    this.addPropertyToElement(input, "placeholder", placeholder);
    this.addPropertyToElement(input, "minLength", "1");
    this.addPropertyToElement(input, "style", "width: 95%;");
    contentEl.createEl("p", {
      text: COMMAND_PAPER_MODAL_DESC,
      cls: "add-paper-description"
    });
    let running = false;
    contentEl.addEventListener("keydown", (event) => {
      if (event.key !== "Enter")
        return;
      let url = input.value.trim().toLowerCase();
      if (!isValidUrl(url)) {
        new import_obsidian6.Notice("Invalid URL");
        return;
      }
      if (!running) {
        running = true;
        this.fetchPaperDataAndCreateNoteFromUrl(url);
      }
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
  async fetchPaperDataAndCreateNoteFromUrl(url) {
    let paperFetchFunction;
    if (url.includes("arxiv.org")) {
      new import_obsidian6.Notice(NOTICE_RETRIEVING_ARXIV);
      paperFetchFunction = fetchArxivPaperDataFromUrl;
    } else {
      new import_obsidian6.Notice(NOTICE_RETRIEVING_S2);
      paperFetchFunction = (url2) => fetchSemanticScholarPaperDataFromUrl(
        url2,
        this.settings.s2apikey
      );
    }
    paperFetchFunction(url).then(async (paperData) => {
      this.obsidianScholar.downloadAndSavePaperNotePDF(paperData);
    }).catch((error) => {
      new import_obsidian6.Notice(NOTICE_PAPER_NOTE_DOWNLOAD_ERROR);
      console.log(error);
    }).finally(() => {
      this.close();
    });
  }
};
var addPaperPdfModal = class extends import_obsidian6.SuggestModal {
  constructor(app, settings, obsidianScholar) {
    super(app);
    this.localPaperData = [];
    this.settings = settings;
    this.obsidianScholar = obsidianScholar;
    const instructions = [
      ["\u2191\u2193", "to navigate"],
      ["\u21B5", "to select paper"],
      ["esc", "to dismiss"]
    ];
    const modalInstructionsHTML = this.modalEl.createEl("div", {
      cls: "prompt-instructions"
    });
    for (const instruction of instructions) {
      const modalInstructionHTML = modalInstructionsHTML.createDiv({
        cls: "prompt-instruction"
      });
      modalInstructionHTML.createSpan({
        cls: "prompt-instruction-command",
        text: instruction[0]
      });
      modalInstructionHTML.createSpan({ text: instruction[1] });
    }
    this.setPlaceholder("Select paper to add PDF to");
    this.localPaperData = this.app.vault.getMarkdownFiles().filter((file) => file.path.startsWith(this.settings.NoteLocation)).map((file, index) => {
      return {
        paper: this.obsidianScholar.getPaperDataFromLocalFile(file),
        resultType: "local",
        localFilePath: file.path,
        paperIndex: index
      };
    });
    const currentFile = this.app.workspace.getActiveFile();
    if (currentFile && this.obsidianScholar.isFileInNoteLocation(currentFile)) {
      const currentFileIndex = this.localPaperData.findIndex(
        (item) => item.localFilePath === currentFile.path
      );
      if (currentFileIndex > -1) {
        const currentPaper = this.localPaperData.splice(currentFileIndex, 1)[0];
        this.localPaperData.unshift(currentPaper);
      }
    }
  }
  getSuggestions(query) {
    if (query.length === 0) {
      return this.localPaperData.slice(0, 10);
    }
    return this.localPaperData.filter((item) => {
      const title = item.paper.title.toLowerCase();
      const authors = item.paper.authors.join(" ").toLowerCase();
      const searchTerm = query.toLowerCase();
      return title.includes(searchTerm) || authors.includes(searchTerm);
    }).slice(0, 10);
  }
  renderSuggestion(paper, el) {
    const paperData = paper.paper;
    el.createEl("div", { text: paperData.title, cls: "paper-title" });
    if (paperData.authors.length > 0) {
      el.createEl("div", {
        text: paperData.authors.join(", "),
        cls: "paper-authors"
      });
    }
    if (paperData.venue) {
      el.createEl("div", { text: paperData.venue, cls: "paper-venue" });
    }
  }
  onChooseSuggestion(paper, evt) {
    new pdfPathInputModal(
      this.app,
      this.settings,
      this.obsidianScholar,
      paper.localFilePath
    ).open();
  }
};
var pdfPathInputModal = class extends import_obsidian6.SuggestModal {
  constructor(app, settings, obsidianScholar, notePath) {
    super(app);
    this.existingPdfPath = null;
    this.settings = settings;
    this.obsidianScholar = obsidianScholar;
    this.notePath = notePath;
    const noteFile = this.app.vault.getAbstractFileByPath(notePath);
    if (noteFile && noteFile instanceof import_obsidian6.TFile) {
      const paperData = this.obsidianScholar.getPaperDataFromLocalFile(noteFile);
      this.existingPdfPath = paperData.pdfPath || null;
      this.paperTitle = paperData.title;
    } else {
      this.paperTitle = "Unknown Paper";
    }
    const instructions = [
      ["\u2191\u2193", "to navigate"],
      ["\u21B5", "to select/add PDF"],
      ["esc", "to dismiss"]
    ];
    const modalInstructionsHTML = this.modalEl.createEl("div", {
      cls: "prompt-instructions"
    });
    for (const instruction of instructions) {
      const modalInstructionHTML = modalInstructionsHTML.createDiv({
        cls: "prompt-instruction"
      });
      modalInstructionHTML.createSpan({
        cls: "prompt-instruction-command",
        text: instruction[0]
      });
      modalInstructionHTML.createSpan({ text: instruction[1] });
    }
    if (this.existingPdfPath) {
      if (import_obsidian6.Platform.isDesktop) {
        this.setPlaceholder("Enter PDF URL or path (current PDF shown in suggestions)");
      } else {
        this.setPlaceholder("Enter PDF URL (local files not supported on mobile)");
      }
    } else {
      if (import_obsidian6.Platform.isDesktop) {
        this.setPlaceholder("Enter PDF URL or local file path");
      } else {
        this.setPlaceholder("Enter PDF URL (local files not supported on mobile)");
      }
    }
    const descEl = this.modalEl.createEl("div", {
      cls: "add-paper-pdf-description"
    });
    if (this.existingPdfPath) {
      const behavior = this.settings.overridePdfs ? "replace" : "backup";
      const behaviorText = this.settings.overridePdfs ? "The existing PDF will be replaced." : "The existing PDF will be backed up with a timestamp.";
      let platformNote = import_obsidian6.Platform.isDesktop ? "" : " Note: Local file copying is only available on desktop.";
      descEl.setText(`Adding PDF to "${this.paperTitle}". ${behaviorText}${platformNote}`);
    } else {
      let platformNote = import_obsidian6.Platform.isDesktop ? "Enter a URL to download or local path to copy." : "Enter a URL to download. Local files are not supported on mobile.";
      descEl.setText(`Adding PDF to "${this.paperTitle}". ${platformNote}`);
    }
  }
  getSuggestions(query) {
    const suggestions = [];
    if (this.existingPdfPath) {
      suggestions.push(this.existingPdfPath);
    }
    if (!query.trim()) {
      return suggestions;
    }
    if (query.trim() && !suggestions.includes(query.trim())) {
      suggestions.push(query.trim());
    }
    if (query.startsWith("http")) {
      const commonDomains = [
        "https://arxiv.org/pdf/",
        "https://www.semanticscholar.org/",
        "https://aclanthology.org/"
      ];
      for (const domain of commonDomains) {
        if (domain.startsWith(query) && !suggestions.includes(domain)) {
          suggestions.push(domain);
        }
      }
    }
    if (import_obsidian6.Platform.isDesktop) {
      if (query.startsWith("/") || query.startsWith("./") || query.startsWith("~/")) {
        const commonPaths = [
          "~/Downloads/",
          "~/Documents/",
          "~/Desktop/"
        ];
        for (const path of commonPaths) {
          if (path.startsWith(query) && !suggestions.includes(path)) {
            suggestions.push(path);
          }
        }
      }
      if (query.match(/^[A-Za-z]:/) && import_obsidian6.Platform.isWin) {
        const commonWinPaths = [
          "C:\\Users\\",
          "C:\\Downloads\\",
          "D:\\"
        ];
        for (const path of commonWinPaths) {
          if (path.toLowerCase().startsWith(query.toLowerCase()) && !suggestions.includes(path)) {
            suggestions.push(path);
          }
        }
      }
    }
    return suggestions.slice(0, 5);
  }
  renderSuggestion(pdfPath, el) {
    const containerEl = el.createDiv({ cls: "pdf-path-suggestion" });
    const isExisting = pdfPath === this.existingPdfPath;
    if (isExisting) {
      containerEl.createDiv({
        text: pdfPath,
        cls: "pdf-path-existing"
      });
      const behaviorText = this.settings.overridePdfs ? "Current PDF (will be replaced)" : "Current PDF (will be backed up)";
      containerEl.createDiv({
        text: behaviorText,
        cls: "pdf-path-label"
      });
    } else {
      containerEl.createDiv({
        text: pdfPath,
        cls: "pdf-path-new"
      });
      let label = "";
      const isLocalPath = pdfPath.startsWith("/") || pdfPath.startsWith("./") || pdfPath.startsWith("~/") || pdfPath.match(/^[A-Za-z]:/);
      if (pdfPath.startsWith("http")) {
        label = "Download from URL";
      } else if (isLocalPath) {
        if (import_obsidian6.Platform.isDesktop) {
          label = "Copy from local path";
        } else {
          label = "Local path (not supported on mobile)";
        }
      } else {
        label = "Add as path";
      }
      if (this.existingPdfPath) {
        if (isLocalPath && !import_obsidian6.Platform.isDesktop) {
          label = "Local path (not supported on mobile)";
        } else {
          const action = this.settings.overridePdfs ? "replace" : "backup";
          label += ` (will ${action} existing)`;
        }
      }
      containerEl.createDiv({
        text: label,
        cls: "pdf-path-label"
      });
    }
  }
  async onChooseSuggestion(pdfPath, evt) {
    if (!pdfPath.trim()) {
      new import_obsidian6.Notice("Please enter a PDF URL or local path.");
      return;
    }
    const isLocalPath = pdfPath.startsWith("/") || pdfPath.startsWith("./") || pdfPath.startsWith("~/") || pdfPath.match(/^[A-Za-z]:/);
    if (isLocalPath && !import_obsidian6.Platform.isDesktop) {
      new import_obsidian6.Notice("Local file copying is only available on desktop platforms. Please use a URL instead.");
      return;
    }
    try {
      await this.obsidianScholar.addPdfToPaper(this.notePath, pdfPath.trim());
      this.close();
    } catch (error) {
    }
  }
};

/* nosourcemap */